---
layout: base
title: Scorecard
---

<style>
  .table-container {
    overflow-x: auto;
  }
  table.data {
    width: 100%;
    border-collapse: collapse;
    margin-bottom: 1em;
  }
  table.data th,
  table.data td {
    border: 1px solid #ddd;
    padding: 8px;
    text-align: left;
  }
  table.data th {
    background-color: #f2f2f2;
  }
</style>
<div class="content">
  <div class='responsive-flex'>
    <h1>Scorecard</h1>
    <div>
      <input type="radio" id="window_180" name="window" value="180" checked>
        <label for="window_180">180 days</label>
        <input type="radio" id="window_90" name="window" value="90">
          <label for="window_90">90 days</label>
        </div>
      </div>
      <div
        id="map-container" style="width: 100%; max-width: 975px; overflow: hidden;"><!-- D3.js map will be rendered here -->
      </div>
      <div>
        <p class="small-note">
          Station and observation data are from
          <a href="/catalog/asos-parquet/">asos-parquet</a>. See
          <a href="/scorecard/observation-data/">observation data details</a> and
          <a href="/scorecard/metrics/">how metrics are computed</a>.
        </p>
      </div>
      <div class="responsive-flex">
        <h2>Temperature</h2>
        <select id="temp-metric"></select>
      </div>
      <div id="temperature-chart" class="scorecard-chart"></div>
      <div class="responsive-flex">
        <h2>Precipitation</h2>
        <select id="precip-metric"></select>
      </div>
      <div id="precipitation-chart" class="scorecard-chart"></div>
      <div id="station-list">
        {% for state, stations_in_state in scorecard.index.stations | sort(attribute="state_name") | groupby("state_name") %}
          <h3>
            <a href='/scorecard/us-state/{{ stations_in_state[0].state_abbr | slug }}'>{{ state }}</a>
          </h3>
          <ul>
            {% for station in stations_in_state %}
              <li>
                <a href="/scorecard/station/{{ station.id }}/">{{ station.name }}</a>
                <span style='color: gray;'>[{{ station.id }}]</span>
              </li>
            {% endfor %}
          </ul>
        {% endfor %}
      </div>
    </div>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://unpkg.com/topojson-client@3"></script>
    <script>
      const width = 975;
      const height = 610;
      const projection = d3
        .geoAlbersUsa()
        .scale(1300)
        .translate([487.5, 305]);
      const path = d3.geoPath();
      const svg = d3
        .select("#map-container")
        .append("svg")
        .attr("viewBox", [0, 0, width, height])
        .attr("width", "100%")
        .attr("height", "auto")
        .attr("style", "max-width: 100%;");
      d3.json("https://cdn.jsdelivr.net/npm/us-atlas@3/states-albers-10m.json").then(us => {
        svg
          .append("g")
          .attr("fill", "#fff")
          .attr("stroke", "#000")
          // Create <a> elements and link each to its state page, then append the path inside
          .selectAll("a.state-link")
          .data(topojson.feature(us, us.objects.states).features)
          .join("a")
          .attr("class", "state-link")
          .attr("xlink:href", d => {
            const states = {{ scorecard.index.states | dump | safe }};
            const stateObj = states.find(s => s.name === d.properties.name);
            return stateObj
              ? `/scorecard/us-state/${
                stateObj.abbr.toLowerCase()
              }/`
              : null;
          })
          .style("cursor", "pointer")
          .append("path")
          .attr("d", path);
        svg
          .append("path")
          .attr("fill", "none")
          .attr("stroke", "#000")
          .attr("stroke-linejoin", "round")
          .attr("d", path(topojson.mesh(us, us.objects.states, (a, b) => a !== b)));
        const stations = {{ scorecard.index.stations | dump | safe }};
        svg
          .selectAll(".station")
          .data(stations)
          .enter()
          .filter(d => projection([d.longitude, d.latitude]))
          .append("circle")
          .attr("class", "station")
          .attr("cx", d => projection([d.longitude, d.latitude])[0])
          .attr("cy", d => projection([d.longitude, d.latitude])[1])
          .attr("r", 3)
          .attr("fill", "blue")
          .style("pointer-events", "none")
          .append("title")
          .text(d => d.name);
      });
    </script>
    <script type="module">
      import { renderMetric, VARIABLE_METRICS, DEFAULT_METRIC } from '/scorecard.js';

      // Populate metric dropdowns
      function populateMetricSelect(selectEl, variable) {
        const metrics = VARIABLE_METRICS[variable];
        const defaultMetric = DEFAULT_METRIC[variable];
        metrics.forEach(m => {
          const opt = document.createElement('option');
          opt.value = m;
          opt.textContent = m === 'FrequencyBias' ? 'Frequency Bias' : m;
          if (m === defaultMetric) opt.selected = true;
          selectEl.appendChild(opt);
        });
      }

      const tempMetricEl = document.getElementById('temp-metric');
      const precipMetricEl = document.getElementById('precip-metric');
      populateMetricSelect(tempMetricEl, 'temperature_2m');
      populateMetricSelect(precipMetricEl, 'precipitation_surface');

      const tempEl = document.getElementById('temperature-chart');
      const precipEl = document.getElementById('precipitation-chart');
      let windowDays = 180;

      function renderTemp() {
        renderMetric(tempEl, { variable: 'temperature_2m', metric: tempMetricEl.value, windowDays });
      }
      function renderPrecip() {
        renderMetric(precipEl, { variable: 'precipitation_surface', metric: precipMetricEl.value, windowDays });
      }
      function renderAll() { renderTemp(); renderPrecip(); }

      renderAll();

      document.querySelectorAll('input[name="window"]').forEach(radio => {
        radio.addEventListener('change', () => {
          windowDays = Number(radio.value);
          renderAll();
        });
      });
      tempMetricEl.addEventListener('change', renderTemp);
      precipMetricEl.addEventListener('change', renderPrecip);
    </script>