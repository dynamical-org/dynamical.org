---
layout: base
pagination:
  data: scorecard.index.states
  size: 1
  alias: state
permalink: /scorecard/us-state/{{ state.abbr | slug }}/
---

<div class="content">
  <div>
    <a href="/scorecard">Scorecard</a>
    > {{ state.name }}
  </div>
  <div class='responsive-flex'>
    <h1>{{ state.name }}</h1>
    <div>
      <input type="radio" id="window_180" name="window" value="180" checked>
        <label for="window_180">180 days</label>
        <input type="radio" id="window_90" name="window" value="90">
          <label for="window_90">90 days</label>
        <input type="radio" id="window_30" name="window" value="30">
          <label for="window_30">30 days</label>
        <input type="radio" id="window_14" name="window" value="14">
          <label for="window_14">14 days</label>
        <input type="radio" id="window_7" name="window" value="7">
          <label for="window_7">7 days</label>
        </div>
      </div>
      <div
        id="map-container" style="margin: 40px 0; width: 100%; max-width: 975px; overflow: hidden;"><!-- D3.js map will be rendered here -->
      </div>
      <div>
        <p class="small-note">
          Station and observation data are from
          <a href="/catalog/asos-parquet/">asos-parquet</a>. See
          <a href="/scorecard/observation-data/">observation data details</a> and
          <a href="/scorecard/metrics/">how metrics are computed</a>.
        </p>
      </div>
      <div class="responsive-flex">
        <h2>Temperature</h2>
        <select id="temp-metric"></select>
      </div>
      <div id="temperature-chart" class="scorecard-chart"></div>
      <div class="responsive-flex">
        <h2>Precipitation</h2>
        <select id="precip-metric"></select>
      </div>
      <div id="precipitation-chart" class="scorecard-chart"></div>
      <div id="station-list">
        <h2>Stations in {{ state.name }}</h2>
        <ul>
          {% for station in scorecard.index.stations %}
            {% if station.state_abbr == state.abbr %}
              <li>
                <a href="/scorecard/station/{{ station.id }}/">{{ station.name }}</a>
              </li>
            {% endif %}
          {% endfor %}
        </ul>
      </div>
    </div>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://unpkg.com/topojson-client@3"></script>
    <script>
      const width = 975;
      const height = 610;
      const stateName = "{{ state.name }}";
      const stateAbbr = "{{ state.abbr }}";
      const svg = d3
        .select("#map-container")
        .append("svg")
        .attr("viewBox", [0, 0, width, height])
        .attr("width", "100%")
        .attr("height", "auto")
        .attr("style", "max-width: 100%;");
      d3.json("https://cdn.jsdelivr.net/npm/us-atlas@3/states-10m.json").then(us => {
        const state = topojson
          .feature(us, us.objects.states)
          .features
          .find(d => d.properties.name === stateName);
        let projection = d3
          .geoIdentity()
          .reflectY(true)
          .fitExtent([
            [
              0, 0
            ],
            [
              width, height
            ]
          ], state);
        if (stateAbbr === "AK") {
          projection = d3.geoAlbersUsa().fitExtent([
            [
              0, 0
            ],
            [
              width, height
            ]
          ], state);
        } else if (stateAbbr === "HI") {
          projection = d3.geoMercator().fitExtent([
            [
              0, 0
            ],
            [
              width, height
            ]
          ], state);
        }
        const path = d3.geoPath(projection);
        // 2. Draw the state fill (no border yet)
        svg
          .append("path")
          .datum(state)
          .attr("d", path)
          .attr("fill", "#fff")
          .attr("stroke", "none");
        // 2b. Draw county boundaries within the state
        d3.json("https://cdn.jsdelivr.net/npm/us-atlas@3/counties-10m.json").then(usCounties => {
          const counties = topojson.feature(usCounties, usCounties.objects.counties).features;
          const stateIdStr = String(state.id).padStart(2, "0");
          const countiesInState = counties.filter(c => String(c.id).padStart(5, "0").startsWith(stateIdStr));
          svg
            .append("g")
            .attr("class", "counties")
            .selectAll("path")
            .data(countiesInState)
            .enter()
            .append("path")
            .attr("d", path)
            .attr("fill", "none")
            .attr("stroke", "#bbb")
            .attr("stroke-width", 0.5);
          // Draw the state border on top for clarity
          svg
            .append("path")
            .datum(state)
            .attr("d", path)
            .attr("fill", "none")
            .attr("stroke", "#000")
            .attr("stroke-width", 1);
        });
        // 3. Project stations
        const stations = {{ scorecard.index.stations | dump | safe }}.filter(s => s.state_abbr === stateAbbr);
        svg
          .selectAll(".station")
          .data(stations)
          .enter()
          .append("a")
          .attr("xlink:href", d => `/scorecard/station/${
            d.id
          }/`)
          .append("circle")
          .attr("class", "station")
          .attr("r", 5)
          .attr("fill", "blue")
          .attr("cx", d => projection([d.longitude, d.latitude])[0])
          .attr("cy", d => projection([d.longitude, d.latitude])[1])
          .append("title")
          .text(d => d.name);
        // Crop SVG viewBox to the state's vertical bounds to remove extra whitespace
        const bounds = path.bounds(state);
        const y0 = bounds[0][1];
        const y1 = bounds[1][1];
        const shapeHeight = y1 - y0;
        console.log(shapeHeight)
        svg.attr("viewBox", [
          0,
          y0,
          width,
          shapeHeight * 1.1
        ]);
      });
    </script>
    <script type="module">
      import { renderMetric, VARIABLE_METRICS, DEFAULT_METRIC } from '/scorecard.js';

      function populateMetricSelect(selectEl, variable) {
        const metrics = VARIABLE_METRICS[variable];
        const defaultMetric = DEFAULT_METRIC[variable];
        metrics.forEach(m => {
          const opt = document.createElement('option');
          opt.value = m;
          opt.textContent = m === 'FrequencyBias' ? 'Frequency Bias' : m;
          if (m === defaultMetric) opt.selected = true;
          selectEl.appendChild(opt);
        });
      }

      const tempMetricEl = document.getElementById('temp-metric');
      const precipMetricEl = document.getElementById('precip-metric');
      populateMetricSelect(tempMetricEl, 'temperature_2m');
      populateMetricSelect(precipMetricEl, 'precipitation_surface');

      const stationIds = {{ scorecard.index.stations | dump | safe }}
        .filter(s => s.state_abbr === '{{ state.abbr }}')
        .map(s => s.id);
      const tempEl = document.getElementById('temperature-chart');
      const precipEl = document.getElementById('precipitation-chart');
      let windowDays = 180;

      function renderTemp() {
        renderMetric(tempEl, { variable: 'temperature_2m', metric: tempMetricEl.value, stationIds, windowDays });
      }
      function renderPrecip() {
        renderMetric(precipEl, { variable: 'precipitation_surface', metric: precipMetricEl.value, stationIds, windowDays });
      }
      function renderAll() { renderTemp(); renderPrecip(); }

      renderAll();

      document.querySelectorAll('input[name="window"]').forEach(radio => {
        radio.addEventListener('change', () => {
          windowDays = Number(radio.value);
          renderAll();
        });
      });
      tempMetricEl.addEventListener('change', renderTemp);
      precipMetricEl.addEventListener('change', renderPrecip);
    </script>